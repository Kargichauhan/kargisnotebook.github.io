<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sorting, Searching, and Thinking in Interviews</title>
  <link rel="stylesheet" href="../style.css" />
  <link rel="icon" href="../favicon.ico" type="image/x-icon" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    body {
      max-width: 760px;
      margin: auto;
      padding: 2.5rem 1rem;
      font-family: 'Inter', sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      font-size: 1.05rem;
      line-height: 1.7;
    }
    h1 { font-size: 2.2rem; margin-bottom: 0.5rem; }
    .meta { font-size: 0.9rem; color: var(--meta-color); margin-bottom: 2rem; }
    h2 { color: #7bed9f; margin-top: 2.5rem; }
    h3 { margin-top: 2rem; }
    code { background: #2e2e2e; padding: 0.25rem 0.4rem; border-radius: 5px; color: #b8f5c8; }
    pre {
      background: #2e2e2e;
      padding: 1rem;
      border-radius: 8px;
      overflow-x: auto;
      font-family: monospace;
      font-size: 0.9rem;
      color: #d5f9dc;
    }
    details.toc {
      background: var(--card-color);
      padding: 1rem;
      border-radius: 10px;
      margin-bottom: 2rem;
      box-shadow: 0 4px 10px var(--shadow);
    }
    .citation-container {
      position: relative;
      margin-top: 1.5rem;
    }
    .cite-box {
      background: #2b2b2b;
      padding: 1rem;
      border-radius: 8px;
      white-space: pre-wrap;
      font-family: monospace;
      font-size: 0.9rem;
      color: #d0f7cf;
    }
    #copy-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: #4caf50;
      color: white;
      border: none;
      padding: 0.4rem 0.8rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.8rem;
    }
    #copy-btn:hover { background-color: #45a049; }
  </style>
</head>
<body>
  <h1>Sorting and Searching</h1>
  <p class="meta">Date: May 9, 2025 ‚Ä¢ Estimated Reading Time: 10‚Äì12 min ‚Ä¢ Author: Kargi Chauhan</p>

  <details class="toc">
    <summary>üìö Table of Contents</summary>
    <ul>
      <li><a href="#intro">What I‚Äôm sipping today ‚òï</a></li>
      <li><a href="#basics">Sorting & Searching ‚Äî Core Concepts</a></li>
      <li><a href="#rotated-search">Problem 1: Search in Rotated Sorted Array</a></li>
      <li><a href="#median-arrays">Problem 2: Median of Two Sorted Arrays</a></li>
      <li><a href="#citation">Citation</a></li>
    </ul>
  </details>

  <h2 id="intro">What I‚Äôm sipping today ‚òï</h2>
  <p>
    Iced blueberry matcha. Cold, slightly sweet, and green ‚Äî kind of like how search problems feel when you finally crack them.
  </p>

  <h2 id="basics">Sorting & Searching ‚Äî Core Concepts</h2>
  <p>
    Sorting and searching are foundational. Almost every algorithm builds on them. Understand them well, and you'll start to see these patterns appear again and again ‚Äî just in different clothes.
  </p>

  <h3>1. Linear Search (O(n))</h3>
  <pre><code>def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1</code></pre>

  <h3>2. Binary Search (O(log n))</h3>
  <pre><code>def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1</code></pre>

  <h3>3. Built-In Sorting</h3>
  <pre><code>nums = [5, 2, 9, 1]
nums.sort()
sorted_nums = sorted(nums)</code></pre>

  <h3>4. Custom Sorting with <code>key=</code></h3>
  <pre><code>names = ["kargi", "blueberry", "chai", "ada"]
sorted_by_length = sorted(names, key=len)
sorted_by_last = sorted(names, key=lambda x: x[-1])</code></pre>

  <h3>5. Common Sorting Algorithms</h3>
  <ul>
    <li>Bubble Sort ‚Äî simple, but inefficient</li>
    <li>Merge Sort ‚Äî divide & conquer, stable</li>
    <li>Quick Sort ‚Äî fast average case, not stable</li>
    <li>Heap Sort ‚Äî consistent O(n log n)</li>
  </ul>

  <h2> Problem 1 [33. Search in Rotated Sorted Array] </h2>
<blockquote>
There is an integer array <code>nums</code> sorted in ascending order (with distinct values).<br><br>
Prior to being passed to your function, <code>nums</code> is possibly rotated at an unknown pivot index <code>k</code> (1 &lt;= k &lt; nums.length) such that the resulting array is:<br>
<code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (0-indexed).<br><br>
For example, <code>[0,1,2,4,5,6,7]</code> might be rotated at pivot index 3 and become <code>[4,5,6,7,0,1,2]</code>.<br><br>
Given the array <code>nums</code> after the possible rotation and an integer <code>target</code>, return the index of <code>target</code> if it is in <code>nums</code>, or <code>-1</code> if it is not in <code>nums</code>.<br><br>
You must write an algorithm with <strong>O(log n)</strong> runtime complexity.
</blockquote>

<h3>Examples:</h3>
<pre><code>Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1

Input: nums = [1], target = 0
Output: -1</code></pre>

<h3>Constraints:</h3>
<ul>
  <li>1 &lt;= nums.length &lt;= 5000</li>
  <li>-10‚Å¥ &lt;= nums[i], target &lt;= 10‚Å¥</li>
  <li>All values of nums are unique</li>
  <li>nums is an ascending array that is possibly rotated</li>
</ul>

  <h3>Step 1: Clarify the problem</h3>
<p>
I‚Äôm going to walk through how I‚Äôd approach this question during an interview ‚Äî not just solving it, but explaining my thought process, edge cases, and trade-offs along the way.
</p>
<p>
So I‚Äôm given a sorted array that has been rotated at some unknown pivot, and the goal is to return the index of a target element if it exists or -1 if it doesn‚Äôt.
</p>
<pre><code>Input: nums = [4,5,6,7,0,1,2], target = 0  
Output: 4</code></pre>
<p>
The first thing I‚Äôd ask the interviewer:
</p>
<ul>
  <li>Can I assume the array contains no duplicates?</li>
  <li>Is the array always non-empty?</li>
  <li>Do I need to worry about integer overflow?</li>
</ul>
<p>
Clarifying these upfront helps rule out tricky edge cases before jumping to code.
</p>

  <h3>Step 2: Think Out Loud</h3>
  <p>One half is always sorted. So use binary search smartly:</p>
  <ol>
    <li>Find mid</li>
    <li>Check which half is sorted</li>
    <li>Adjust search space</li>
  </ol>

  <h3>Step 3: Code</h3>
  <pre><code>def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1</code></pre>

  <h3>Step 4: Walkthrough</h3>
  <p>Dry run it on <code>[4,5,6,7,0,1,2]</code> with <code>target = 0</code> ‚Äî it works perfectly.</p>

  <h3>Step 5: Complexity</h3>
  <p>Time: O(log n) ‚Ä¢ Space: O(1)</p>

  <h2> Problem 2 [Median of Two Sorted Arrays] </h2>
<blockquote>
Given two sorted arrays <code>nums1</code> and <code>nums2</code> of size <code>m</code> and <code>n</code> respectively, return the median of the two sorted arrays.<br><br>
The overall run time complexity should be <strong>O(log (m+n))</strong>.
</blockquote>

<h3>Examples:</h3>
<pre><code>Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2

Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5</code></pre>



  <h3>Step 1: Clarify</h3>
  <p>Find the median without merging. Can I use O(m+n)? No, it asks for O(log(min(m,n))).</p>

  <h3>Option 1: Brute Force</h3>
  <pre><code>def findMedianSortedArrays(nums1, nums2):
    merged = sorted(nums1 + nums2)
    n = len(merged)
    if n % 2 == 1:
        return float(merged[n // 2])
    else:
        return (merged[n // 2 - 1] + merged[n // 2]) / 2</code></pre>

  <h3>Option 2: Merge Sort Logic</h3>
  <pre><code>def findMedianSortedArrays(nums1, nums2):
    merged = []
    i = j = 0
    while i < len(nums1) and j < len(nums2):
        if nums1[i] < nums2[j]:
            merged.append(nums1[i])
            i += 1
        else:
            merged.append(nums2[j])
            j += 1
    merged.extend(nums1[i:])
    merged.extend(nums2[j:])
    n = len(merged)
    if n % 2 == 1:
        return float(merged[n // 2])
    else:
        return (merged[n // 2 - 1] + merged[n // 2]) / 2</code></pre>

  <h3>Option 3: Optimal Binary Search</h3>
  <pre><code>class Solution:
    def findMedianSortedArrays(self, nums1, nums2):
        if len(nums1) > len(nums2):
            nums1, nums2 = nums2, nums1
        x, y = len(nums1), len(nums2)
        low, high = 0, x
        while low <= high:
            partitionX = (low + high) // 2
            partitionY = (x + y + 1) // 2 - partitionX
            maxLeftX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]
            minRightX = float('inf') if partitionX == x else nums1[partitionX]
            maxLeftY = float('-inf') if partitionY == 0 else nums2[partitionY - 1]
            minRightY = float('inf') if partitionY == y else nums2[partitionY]
            if maxLeftX <= minRightY and maxLeftY <= minRightX:
                if (x + y) % 2 == 0:
                    return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2
                else:
                    return max(maxLeftX, maxLeftY)
            elif maxLeftX > minRightY:
                high = partitionX - 1
            else:
                low = partitionX + 1
        return -1</code></pre>

        <h3>Why This Works</h3>
        <p>
        We‚Äôre trying to split both arrays into two halves such that:
        </p>
        <ul>
          <li>All elements on the left side ‚â§ all elements on the right</li>
          <li>The number of elements is balanced (or off by 1 if odd total)</li>
        </ul>
        <p>
        Once that condition holds, the median can be found using just the border values ‚Äî max of left, min of right.
        </p>
        <p>
        And since we're using binary search only on the shorter array, the time complexity becomes <strong>O(log(min(m, n)))</strong> as required.
        </p>
        
        <h3>Final Thoughts</h3>
        <p>
        This problem isn‚Äôt just about finding a median.
        It‚Äôs about knowing when brute force won't scale and shifting into an algorithmic mindset when constraints demand it.
        </p>
        <p>
        In an interview, it's absolutely okay to start simple as long as you show that you're willing and able to evolve your solution thoughtfully.
        </p>

  <h2 id="citation">Citation</h2>
  <p>Cite this blog post as:</p>
  <div class="citation-container">
    <pre id="bibtex" class="cite-box">@article{kargi2025sortsearch,
  title   = "Sorting, Searching, and Thinking in Interviews",
  author  = "Kargi Chauhan",
  journal = "kargisnotebook.github.io",
  year    = "2025",
  month   = "May",
  url     = "https://kargichauhan.github.io/kargisnotebook.github.io/posts/Sorting-Searching-DeepDive.html"
}</pre>
    <button id="copy-btn">üìã Copy</button>
  </div>

  <script>
    const html = document.documentElement;
    const currentTheme = localStorage.getItem("theme") || "light";
    html.dataset.theme = currentTheme;
    const toggle = document.getElementById("theme-toggle");
    if (toggle) {
      toggle.textContent = currentTheme === "light" ? "üåô" : "‚òÄÔ∏è";
      toggle.onclick = () => {
        const next = html.dataset.theme === "light" ? "dark" : "light";
        html.dataset.theme = next;
        localStorage.setItem("theme", next);
        toggle.textContent = next === "light" ? "üåô" : "‚òÄÔ∏è";
      };
    }
    const copyBtn = document.getElementById("copy-btn");
    copyBtn.addEventListener("click", () => {
      navigator.clipboard.writeText(document.getElementById("bibtex").textContent).then(() => {
        copyBtn.textContent = "‚úÖ Copied!";
        setTimeout(() => (copyBtn.textContent = "üìã Copy"), 2000);
      });
    });
  </script>
</body>
</html>
